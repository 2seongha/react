<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, shrink-to-fit=no, viewport-fit=cover, interactive-widget=overlays-content">
    <meta name="format-detection" content="telephone=no">
    <meta name="msapplication-tap-highlight" content="no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <title>iFLOW5</title>
    
    <!-- Pretendard 폰트 preload (중요 웨이트만) -->
    <link rel="preload" href="/assets/fonts/Pretendard-Regular.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="/assets/fonts/Pretendard-Medium.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="/assets/fonts/Pretendard-SemiBold.woff2" as="font" type="font/woff2" crossorigin>
    
    <style>
      /* Pretendard 폰트 정의 - 최적화된 순서 */
      @font-face {
        font-family: 'Pretendard';
        font-weight: 400;
        font-style: normal;
        font-display: swap;
        src: url('/assets/fonts/Pretendard-Regular.woff2') format('woff2');
      }
      
      @font-face {
        font-family: 'Pretendard';
        font-weight: 500;
        font-style: normal;
        font-display: swap;
        src: url('/assets/fonts/Pretendard-Medium.woff2') format('woff2');
      }
      
      @font-face {
        font-family: 'Pretendard';
        font-weight: 600;
        font-style: normal;
        font-display: swap;
        src: url('/assets/fonts/Pretendard-SemiBold.woff2') format('woff2');
      }
      
      @font-face {
        font-family: 'Pretendard';
        font-weight: 700;
        font-style: normal;
        font-display: swap;
        src: url('/assets/fonts/Pretendard-Bold.woff2') format('woff2');
      }
      
      @font-face {
        font-family: 'Pretendard';
        font-weight: 300;
        font-style: normal;
        font-display: swap;
        src: url('/assets/fonts/Pretendard-Light.woff2') format('woff2');
      }
      
      @font-face {
        font-family: 'Pretendard';
        font-weight: 100;
        font-style: normal;
        font-display: swap;
        src: url('/assets/fonts/Pretendard-Thin.woff2') format('woff2');
      }
      
      @font-face {
        font-family: 'Pretendard';
        font-weight: 200;
        font-style: normal;
        font-display: swap;
        src: url('/assets/fonts/Pretendard-ExtraLight.woff2') format('woff2');
      }
      
      @font-face {
        font-family: 'Pretendard';
        font-weight: 800;
        font-style: normal;
        font-display: swap;
        src: url('/assets/fonts/Pretendard-ExtraBold.woff2') format('woff2');
      }
      
      @font-face {
        font-family: 'Pretendard';
        font-weight: 900;
        font-style: normal;
        font-display: swap;
        src: url('/assets/fonts/Pretendard-Black.woff2') format('woff2');
      }
    </style>
  </head>
  <body style="height: 100vh; position: fixed; top: 0; left: 0; right: 0; bottom: 0; overflow: hidden; touch-action: none;">
    <script>
      // 페이지 로드 즉시 Visual Viewport 프록시로 가로채기
      (function() {
        const initialWidth = window.innerWidth;
        const initialHeight = window.innerHeight;
        
        console.log('즉시 Viewport 고정:', initialWidth, 'x', initialHeight);
        
        // Visual Viewport API 프록시로 가로채기
        if (window.visualViewport) {
          const originalViewport = window.visualViewport;
          
          // 모든 속성 접근을 가로채는 프록시 생성
          const viewportProxy = new Proxy(originalViewport, {
            get: function(target, property) {
              // 크기 관련 속성들은 고정값 반환
              if (property === 'width') return initialWidth;
              if (property === 'height') return initialHeight;
              if (property === 'offsetLeft') return 0;
              if (property === 'offsetTop') return 0;
              if (property === 'pageLeft') return 0;
              if (property === 'pageTop') return 0;
              if (property === 'scale') return 1;
              
              // 이벤트 관련 메서드들은 빈 함수 반환
              if (property === 'addEventListener') {
                return function(type, listener, options) {
                  // resize, scroll 이벤트는 무시
                  if (type === 'resize' || type === 'scroll') {
                    return;
                  }
                  return originalViewport.addEventListener.call(originalViewport, type, listener, options);
                };
              }
              
              if (property === 'removeEventListener') {
                return function(type, listener, options) {
                  if (type === 'resize' || type === 'scroll') {
                    return;
                  }
                  return originalViewport.removeEventListener.call(originalViewport, type, listener, options);
                };
              }
              
              // 기타 속성들은 원본값 반환
              return target[property];
            },
            
            set: function(target, property, value) {
              // onresize, onscroll 이벤트 핸들러 설정 무시
              if (property === 'onresize' || property === 'onscroll') {
                return true;
              }
              // 기타 속성 설정은 허용하지 않음
              return true;
            }
          });
          
          // 프록시로 원본 대체 시도
          try {
            Object.defineProperty(window, 'visualViewport', {
              get: function() { return viewportProxy; },
              configurable: true
            });
            console.log('Visual Viewport 프록시 설정 완료');
          } catch (e) {
            console.log('Visual Viewport 프록시 설정 실패:', e);
          }
        }
        
        // window 크기 관련 속성들도 프록시로 가로채기
        const originalWindow = window;
        
        // innerHeight/innerWidth 프록시
        try {
          Object.defineProperty(window, 'innerHeight', {
            get: function() { return initialHeight; },
            configurable: true
          });
          Object.defineProperty(window, 'innerWidth', {
            get: function() { return initialWidth; },
            configurable: true
          });
          console.log('Window 크기 속성 고정 완료');
        } catch (e) {
          console.log('Window 크기 속성 고정 실패:', e);
        }
        
        // resize 이벤트 완전 차단
        const originalAddEventListener = window.addEventListener;
        window.addEventListener = function(type, listener, options) {
          if (type === 'resize' || type === 'orientationchange') {
            console.log('차단된 이벤트:', type);
            return;
          }
          return originalAddEventListener.call(this, type, listener, options);
        };
        
        // 선택적 스크롤 차단 (ion-content와 입력 요소는 허용)
        const preventViewportScrolling = function(e) {
          const target = e.target;
          const isInsideIonContent = target && target.closest && target.closest('ion-content');
          const isInputElement = target && (
            target.tagName === 'INPUT' || 
            target.tagName === 'TEXTAREA' || 
            target.closest('ion-input') || 
            target.closest('ion-textarea') ||
            target.closest('ion-button') ||
            target.closest('ion-item') ||
            target.closest('ion-checkbox') ||
            target.closest('ion-modal') ||
            target.closest('ion-popover')
          );
          
          // ion-content 내부이거나 입력/버튼 요소면 허용
          if (isInsideIonContent || isInputElement) {
            return true;
          }
          
          // 그 외는 차단하되 스크롤 이벤트만 차단 (터치는 부분적으로 허용)
          if (e.type === 'scroll') {
            e.preventDefault();
            e.stopPropagation();
            
            // 강제로 스크롤 위치 복원
            window.scrollTo(0, 0);
            document.body.scrollTop = 0;
            document.documentElement.scrollTop = 0;
            
            return false;
          }
          
          // 터치 이벤트는 덜 강력하게 차단
          if (e.type === 'touchmove' || e.type === 'touchstart' || e.type === 'touchend') {
            // 수직 터치만 차단 (수평 터치는 허용)
            if (e.touches && e.touches.length > 0) {
              // 멀티터치나 빠른 터치는 허용
              return true;
            }
          }
          
          return true;
        };
        
        // 모든 스크롤 관련 이벤트 차단
        const scrollEvents = ['scroll', 'touchmove', 'wheel', 'touchstart', 'touchend', 'gesturestart', 'gesturechange', 'gestureend'];
        const targets = [window, document, document.documentElement, document.body];
        
        // 스크롤 이벤트만 강력하게 차단, 터치는 선택적 차단
        targets.forEach(target => {
          ['scroll', 'wheel'].forEach(eventType => {
            target.addEventListener(eventType, preventViewportScrolling, { 
              passive: false, 
              capture: true 
            });
          });
          
          // 터치 이벤트는 덜 강력하게 차단
          ['touchmove', 'touchstart', 'touchend'].forEach(eventType => {
            target.addEventListener(eventType, preventViewportScrolling, { 
              passive: false, 
              capture: false  // capture 모드 비활성화
            });
          });
        });
        
        // 스크롤 위치를 강제로 (0,0)으로 유지하는 감시자
        const maintainScrollPosition = function() {
          if (window.scrollY !== 0 || window.scrollX !== 0) {
            window.scrollTo(0, 0);
          }
          if (document.body.scrollTop !== 0 || document.body.scrollLeft !== 0) {
            document.body.scrollTop = 0;
            document.body.scrollLeft = 0;
          }
          if (document.documentElement.scrollTop !== 0 || document.documentElement.scrollLeft !== 0) {
            document.documentElement.scrollTop = 0;
            document.documentElement.scrollLeft = 0;
          }
        };
        
        // 지속적으로 스크롤 위치 감시
        setInterval(maintainScrollPosition, 16); // 60fps
        
        // DOM 변형 감시 및 스타일 강제 적용
        const observer = new MutationObserver(function() {
          // 모든 요소에 스크롤 방지 스타일 강제 재적용
          const forceNoScrollStyles = function() {
            const elements = [document.documentElement, document.body];
            elements.forEach(el => {
              if (el) {
                el.style.setProperty('position', 'fixed', 'important');
                el.style.setProperty('top', '0', 'important');
                el.style.setProperty('left', '0', 'important');
                el.style.setProperty('right', '0', 'important');
                el.style.setProperty('bottom', '0', 'important');
                el.style.setProperty('overflow', 'hidden', 'important');
                el.style.setProperty('overflow-x', 'hidden', 'important');
                el.style.setProperty('overflow-y', 'hidden', 'important');
                el.style.setProperty('overscroll-behavior', 'none', 'important');
                el.style.setProperty('touch-action', 'none', 'important');
                el.style.setProperty('width', initialWidth + 'px', 'important');
                el.style.setProperty('height', initialHeight + 'px', 'important');
                el.style.setProperty('min-width', initialWidth + 'px', 'important');
                el.style.setProperty('min-height', initialHeight + 'px', 'important');
                el.style.setProperty('max-width', initialWidth + 'px', 'important');
                el.style.setProperty('max-height', initialHeight + 'px', 'important');
              }
            });
          };
          
          forceNoScrollStyles();
          maintainScrollPosition();
        });
        
        // DOM 전체 감시
        observer.observe(document, {
          childList: true,
          subtree: true,
          attributes: true,
          attributeFilter: ['style', 'class']
        });
        
        // 브라우저의 기본 스크롤 동작 완전 차단
        Object.defineProperty(window, 'scrollTo', {
          value: function(x, y) {
            if (x !== 0 || y !== 0) {
              // 0이 아닌 스크롤 시도는 무시
              return;
            }
            // 0,0으로의 스크롤만 허용
            return HTMLElement.prototype.scrollTo.call(this, 0, 0);
          },
          writable: false,
          configurable: false
        });
        
        Object.defineProperty(window, 'scroll', {
          value: function(x, y) {
            if (x !== 0 || y !== 0) {
              return;
            }
            return HTMLElement.prototype.scroll.call(this, 0, 0);
          },
          writable: false,
          configurable: false
        });
        
        // scrollTop/scrollLeft 속성도 차단
        ['scrollTop', 'scrollLeft'].forEach(prop => {
          [document.body, document.documentElement].forEach(el => {
            if (el) {
              Object.defineProperty(el, prop, {
                get: function() { return 0; },
                set: function(value) { 
                  // 0이 아닌 값 설정 무시
                  if (value !== 0) return;
                },
                configurable: false
              });
            }
          });
        });
        
        // CSS 스타일 강제 주입 및 유지
        const injectForceStyles = function() {
          const existingStyle = document.getElementById('force-no-scroll');
          if (existingStyle) {
            existingStyle.remove();
          }
          
          const forceStyle = document.createElement('style');
          forceStyle.id = 'force-no-scroll';
          forceStyle.textContent = `
            html, body {
              position: fixed !important;
              top: 0 !important;
              left: 0 !important;
              right: 0 !important;
              bottom: 0 !important;
              width: ${initialWidth}px !important;
              height: ${initialHeight}px !important;
              min-width: ${initialWidth}px !important;
              min-height: ${initialHeight}px !important;
              max-width: ${initialWidth}px !important;
              max-height: ${initialHeight}px !important;
              overflow: hidden !important;
              overflow-x: hidden !important;
              overflow-y: hidden !important;
              overscroll-behavior: none !important;
              margin: 0 !important;
              padding: 0 !important;
              border: none !important;
            }
            
            #root {
              position: fixed !important;
              top: 0 !important;
              left: 0 !important;
              right: 0 !important;
              bottom: 0 !important;
              width: ${initialWidth}px !important;
              height: ${initialHeight}px !important;
              overflow: hidden !important;
            }
            
            ion-app {
              position: relative !important;
              width: 100% !important;
              height: 100% !important;
              overflow: hidden !important;
            }
            
            /* ion-content는 정상적인 높이와 스크롤 허용 */
            ion-content {
              height: 100% !important;
              touch-action: pan-y !important;
              overflow-y: auto !important;
              -webkit-overflow-scrolling: touch !important;
              position: relative !important;
            }
            
            /* 모든 상호작용 요소들은 터치 허용 */
            ion-content *, 
            ion-input, ion-textarea, input, textarea,
            ion-button, ion-item, ion-checkbox, ion-radio,
            ion-select, ion-datetime, ion-toggle,
            ion-modal, ion-popover, ion-action-sheet {
              touch-action: manipulation !important;
              pointer-events: auto !important;
            }
            
            /* 전체 페이지 요소들은 터치 차단하되 UI 요소는 허용 */
            html, body {
              touch-action: none !important;
            }
          `;
          
          document.head.appendChild(forceStyle);
        };
        
        // 즉시 스타일 주입
        injectForceStyles();
        
        // 주기적으로 스타일 재주입 (다른 CSS가 덮어쓰는 것 방지)
        setInterval(injectForceStyles, 100);
        
        console.log('Viewport 완전 차단 및 DOM 감시 시작 완료');
      })();
    </script>
    <style>
      /* #root 컨테이너도 완전 고정 */
      #root {
        height: 100vh;
        height: calc(var(--vh, 1vh) * 100);
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        overflow: hidden;
        touch-action: none;
      }
      
      /* IonContent 내부에서만 터치 허용 */
      ion-content {
        touch-action: pan-y;
      }
      
      ion-content * {
        touch-action: manipulation;
      }
    </style>
    <div id="root"></div>
    <script type="module">
      import { setupIonicReact } from '@ionic/react';
      setupIonicReact();
    </script>
    <script type="module" src="/src/main.tsx"></script>
    <script>
      function initWebview(){
         if (window.flutter_inappwebview && window.flutter_inappwebview.callHandler) {
            window.flutter_inappwebview.callHandler('Init',JSON.stringify({key:'padding'}));
            window.flutter_inappwebview.callHandler('Init',JSON.stringify({key:'token'}));
            window.flutter_inappwebview.callHandler('Init',JSON.stringify({key:'userInfo'}));
         }
      }
    
      function webviewTheme(theme){
        if(window.flutter_inappwebview && window.flutter_inappwebview.callHandler){
          window.flutter_inappwebview.callHandler('Init',JSON.stringify({key:'theme',value:theme}));
        }
      }
    
      function webviewLogout(){
         if(window.flutter_inappwebview && window.flutter_inappwebview.callHandler){
           window.flutter_inappwebview.callHandler('Auth',JSON.stringify({key:'logout'}));
         }
      }
    
      function webviewPushSetting(){
         if(window.flutter_inappwebview && window.flutter_inappwebview.callHandler){
           window.flutter_inappwebview.callHandler('Base',JSON.stringify({key:'pushSetting'}));
         }
      }
    
      function webviewToast(msg){
        if(window.flutter_inappwebview && window.flutter_inappwebview.callHandler){
          window.flutter_inappwebview.callHandler('Base',JSON.stringify({key:'toast',value:msg}));
        }
      }
    
      function webviewHaptic(type){
        if(window.flutter_inappwebview && window.flutter_inappwebview.callHandler){
          window.flutter_inappwebview.callHandler('Base',JSON.stringify({key:'haptic',value:type}));
        }
      }
    
      function webviewNoticeOnOff(val, org){
        if(window.flutter_inappwebview && window.flutter_inappwebview.callHandler){
          window.flutter_inappwebview.callHandler('Base',JSON.stringify({key:'noticeOnOff',value:
          {val: val, org: org}}));
        }
      }
    
      function webviewAppEnd(value){
        if(window.flutter_inappwebview && window.flutter_inappwebview.callHandler){
          window.flutter_inappwebview.callHandler('Base',JSON.stringify({key:'appEnd'}));
        }
      }
    
      function webviewAttach(title, url){
        if(window.flutter_inappwebview && window.flutter_inappwebview.callHandler){
          window.flutter_inappwebview.callHandler('Base',JSON.stringify({key: 'attach', value: {title: title, url: url}}));
        }
      }
  
      function webviewBadge(badge){
        if(window.flutter_inappwebview && window.flutter_inappwebview.callHandler){
          window.flutter_inappwebview.callHandler('Base',JSON.stringify({key: 'badge', value: {badge: badge}}));
        }
      }
    
      function webviewPrivacyPolicy(){
        if(window.flutter_inappwebview && window.flutter_inappwebview.callHandler){
          window.flutter_inappwebview.callHandler('Base',JSON.stringify({key: 'privacyPolicy'}));
        }
      }
    
      function webviewTermsOfUse(){
        if(window.flutter_inappwebview && window.flutter_inappwebview.callHandler){
          window.flutter_inappwebview.callHandler('Base',JSON.stringify({key: 'termsOfUse'}));
        }
      }
    
       function webviewBiometrics(){
        if(window.flutter_inappwebview && window.flutter_inappwebview.callHandler){
          window.flutter_inappwebview.callHandler('Base',JSON.stringify({key: 'biometrics'}));
        }
      }
    
      function receivePadding(top,bottom,left,right){
        const event = new CustomEvent('receivePadding', { detail: JSON.stringify({top, bottom, left,
        right}) });
        window.dispatchEvent(event);
      }
    
      function receiveToken(deviceToken, deviceInfo){
        console.log(deviceInfo.toString());
        const event = new CustomEvent('receiveToken', { detail: JSON.stringify({deviceToken, deviceInfo}) });
        window.dispatchEvent(event);
      }
    
      function receiveUserInfo(loginId, corp) {
        const event = new CustomEvent('receiveUserInfo', { detail: JSON.stringify({loginId, corp}) });
        window.dispatchEvent(event);
      }
    
      function receiveBack(){
        const event = new CustomEvent('receiveBack', { detail: {} });
        window.dispatchEvent(event);
      }
    
      function receiveBiometrics(didAuthenticate){
        const event = new CustomEvent('receiveBiometrics', { detail: JSON.stringify
        ({didAuthenticate}) });
        window.dispatchEvent(event);
      }
    
       function receiveKeyboard(isOpen, keyboardHeight){
        const event = new CustomEvent('receiveKeyboard', { detail: JSON.stringify({isOpen, keyboardHeight}) });
        window.dispatchEvent(event);
      }
    </script>
  </body>
</html>
