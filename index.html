<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, shrink-to-fit=no, viewport-fit=cover, interactive-widget=overlays-content">
    <meta name="format-detection" content="telephone=no">
    <meta name="msapplication-tap-highlight" content="no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <title>iFLOW5</title>
    
    <!-- Pretendard 폰트 preload (중요 웨이트만) -->
    <link rel="preload" href="/assets/fonts/Pretendard-Regular.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="/assets/fonts/Pretendard-Medium.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="/assets/fonts/Pretendard-SemiBold.woff2" as="font" type="font/woff2" crossorigin>
    
    <style>
      /* Pretendard 폰트 정의 - 최적화된 순서 */
      @font-face {
        font-family: 'Pretendard';
        font-weight: 400;
        font-style: normal;
        font-display: swap;
        src: url('/assets/fonts/Pretendard-Regular.woff2') format('woff2');
      }
      
      @font-face {
        font-family: 'Pretendard';
        font-weight: 500;
        font-style: normal;
        font-display: swap;
        src: url('/assets/fonts/Pretendard-Medium.woff2') format('woff2');
      }
      
      @font-face {
        font-family: 'Pretendard';
        font-weight: 600;
        font-style: normal;
        font-display: swap;
        src: url('/assets/fonts/Pretendard-SemiBold.woff2') format('woff2');
      }
      
      @font-face {
        font-family: 'Pretendard';
        font-weight: 700;
        font-style: normal;
        font-display: swap;
        src: url('/assets/fonts/Pretendard-Bold.woff2') format('woff2');
      }
      
      @font-face {
        font-family: 'Pretendard';
        font-weight: 300;
        font-style: normal;
        font-display: swap;
        src: url('/assets/fonts/Pretendard-Light.woff2') format('woff2');
      }
      
      @font-face {
        font-family: 'Pretendard';
        font-weight: 100;
        font-style: normal;
        font-display: swap;
        src: url('/assets/fonts/Pretendard-Thin.woff2') format('woff2');
      }
      
      @font-face {
        font-family: 'Pretendard';
        font-weight: 200;
        font-style: normal;
        font-display: swap;
        src: url('/assets/fonts/Pretendard-ExtraLight.woff2') format('woff2');
      }
      
      @font-face {
        font-family: 'Pretendard';
        font-weight: 800;
        font-style: normal;
        font-display: swap;
        src: url('/assets/fonts/Pretendard-ExtraBold.woff2') format('woff2');
      }
      
      @font-face {
        font-family: 'Pretendard';
        font-weight: 900;
        font-style: normal;
        font-display: swap;
        src: url('/assets/fonts/Pretendard-Black.woff2') format('woff2');
      }
    </style>
  </head>
  <body style="height: 100vh; position: fixed; top: 0; left: 0; right: 0; bottom: 0; overflow: hidden; touch-action: none;">
    <script>
      // 페이지 로드 즉시 Visual Viewport 프록시로 가로채기
      (function() {
        const initialWidth = window.innerWidth;
        const initialHeight = window.innerHeight;
        
        console.log('즉시 Viewport 고정:', initialWidth, 'x', initialHeight);
        
        // Visual Viewport API 프록시로 가로채기
        if (window.visualViewport) {
          const originalViewport = window.visualViewport;
          
          // 모든 속성 접근을 가로채는 프록시 생성
          const viewportProxy = new Proxy(originalViewport, {
            get: function(target, property) {
              // 크기 관련 속성들은 고정값 반환
              if (property === 'width') return initialWidth;
              if (property === 'height') return initialHeight;
              if (property === 'offsetLeft') return 0;
              if (property === 'offsetTop') return 0;
              if (property === 'pageLeft') return 0;
              if (property === 'pageTop') return 0;
              if (property === 'scale') return 1;
              
              // 이벤트 관련 메서드들은 빈 함수 반환
              if (property === 'addEventListener') {
                return function(type, listener, options) {
                  // resize, scroll 이벤트는 무시
                  if (type === 'resize' || type === 'scroll') {
                    return;
                  }
                  return originalViewport.addEventListener.call(originalViewport, type, listener, options);
                };
              }
              
              if (property === 'removeEventListener') {
                return function(type, listener, options) {
                  if (type === 'resize' || type === 'scroll') {
                    return;
                  }
                  return originalViewport.removeEventListener.call(originalViewport, type, listener, options);
                };
              }
              
              // 기타 속성들은 원본값 반환
              return target[property];
            },
            
            set: function(target, property, value) {
              // onresize, onscroll 이벤트 핸들러 설정 무시
              if (property === 'onresize' || property === 'onscroll') {
                return true;
              }
              // 기타 속성 설정은 허용하지 않음
              return true;
            }
          });
          
          // 프록시로 원본 대체 시도
          try {
            Object.defineProperty(window, 'visualViewport', {
              get: function() { return viewportProxy; },
              configurable: true
            });
            console.log('Visual Viewport 프록시 설정 완료');
          } catch (e) {
            console.log('Visual Viewport 프록시 설정 실패:', e);
          }
        }
        
        // window 크기 관련 속성들도 프록시로 가로채기
        const originalWindow = window;
        
        // innerHeight/innerWidth 프록시
        try {
          Object.defineProperty(window, 'innerHeight', {
            get: function() { return initialHeight; },
            configurable: true
          });
          Object.defineProperty(window, 'innerWidth', {
            get: function() { return initialWidth; },
            configurable: true
          });
          console.log('Window 크기 속성 고정 완료');
        } catch (e) {
          console.log('Window 크기 속성 고정 실패:', e);
        }
        
        // resize 이벤트 완전 차단
        const originalAddEventListener = window.addEventListener;
        window.addEventListener = function(type, listener, options) {
          if (type === 'resize' || type === 'orientationchange') {
            console.log('차단된 이벤트:', type);
            return;
          }
          return originalAddEventListener.call(this, type, listener, options);
        };
        
        // 모든 스크롤 관련 동작 완전 차단
        const preventAllScrolling = function(e) {
          const target = e.target;
          const isInsideIonContent = target && target.closest && target.closest('ion-content');
          
          if (!isInsideIonContent) {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            
            // 강제로 스크롤 위치 복원
            window.scrollTo(0, 0);
            document.body.scrollTop = 0;
            document.documentElement.scrollTop = 0;
            
            return false;
          }
        };
        
        // 모든 스크롤 관련 이벤트 차단
        const scrollEvents = ['scroll', 'touchmove', 'wheel', 'touchstart', 'touchend', 'gesturestart', 'gesturechange', 'gestureend'];
        const targets = [window, document, document.documentElement, document.body];
        
        targets.forEach(target => {
          scrollEvents.forEach(eventType => {
            target.addEventListener(eventType, preventAllScrolling, { 
              passive: false, 
              capture: true 
            });
          });
        });
        
        // 스크롤 위치를 강제로 (0,0)으로 유지하는 감시자
        const maintainScrollPosition = function() {
          if (window.scrollY !== 0 || window.scrollX !== 0) {
            window.scrollTo(0, 0);
          }
          if (document.body.scrollTop !== 0 || document.body.scrollLeft !== 0) {
            document.body.scrollTop = 0;
            document.body.scrollLeft = 0;
          }
          if (document.documentElement.scrollTop !== 0 || document.documentElement.scrollLeft !== 0) {
            document.documentElement.scrollTop = 0;
            document.documentElement.scrollLeft = 0;
          }
        };
        
        // 지속적으로 스크롤 위치 감시
        setInterval(maintainScrollPosition, 16); // 60fps
        
        console.log('Viewport 가로채기 및 스크롤 완전 차단 완료');
      })();
    </script>
    <style>
      /* #root 컨테이너도 완전 고정 */
      #root {
        height: 100vh;
        height: calc(var(--vh, 1vh) * 100);
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        overflow: hidden;
        touch-action: none;
      }
      
      /* IonContent 내부에서만 터치 허용 */
      ion-content {
        touch-action: pan-y;
      }
      
      ion-content * {
        touch-action: manipulation;
      }
    </style>
    <div id="root"></div>
    <script type="module">
      import { setupIonicReact } from '@ionic/react';
      setupIonicReact();
    </script>
    <script type="module" src="/src/main.tsx"></script>
    <script>
      function initWebview(){
         if (window.flutter_inappwebview && window.flutter_inappwebview.callHandler) {
            window.flutter_inappwebview.callHandler('Init',JSON.stringify({key:'padding'}));
            window.flutter_inappwebview.callHandler('Init',JSON.stringify({key:'token'}));
            window.flutter_inappwebview.callHandler('Init',JSON.stringify({key:'userInfo'}));
         }
      }
    
      function webviewTheme(theme){
        if(window.flutter_inappwebview && window.flutter_inappwebview.callHandler){
          window.flutter_inappwebview.callHandler('Init',JSON.stringify({key:'theme',value:theme}));
        }
      }
    
      function webviewLogout(){
         if(window.flutter_inappwebview && window.flutter_inappwebview.callHandler){
           window.flutter_inappwebview.callHandler('Auth',JSON.stringify({key:'logout'}));
         }
      }
    
      function webviewPushSetting(){
         if(window.flutter_inappwebview && window.flutter_inappwebview.callHandler){
           window.flutter_inappwebview.callHandler('Base',JSON.stringify({key:'pushSetting'}));
         }
      }
    
      function webviewToast(msg){
        if(window.flutter_inappwebview && window.flutter_inappwebview.callHandler){
          window.flutter_inappwebview.callHandler('Base',JSON.stringify({key:'toast',value:msg}));
        }
      }
    
      function webviewHaptic(type){
        if(window.flutter_inappwebview && window.flutter_inappwebview.callHandler){
          window.flutter_inappwebview.callHandler('Base',JSON.stringify({key:'haptic',value:type}));
        }
      }
    
      function webviewNoticeOnOff(val, org){
        if(window.flutter_inappwebview && window.flutter_inappwebview.callHandler){
          window.flutter_inappwebview.callHandler('Base',JSON.stringify({key:'noticeOnOff',value:
          {val: val, org: org}}));
        }
      }
    
      function webviewAppEnd(value){
        if(window.flutter_inappwebview && window.flutter_inappwebview.callHandler){
          window.flutter_inappwebview.callHandler('Base',JSON.stringify({key:'appEnd'}));
        }
      }
    
      function webviewAttach(title, url){
        if(window.flutter_inappwebview && window.flutter_inappwebview.callHandler){
          window.flutter_inappwebview.callHandler('Base',JSON.stringify({key: 'attach', value: {title: title, url: url}}));
        }
      }
  
      function webviewBadge(badge){
        if(window.flutter_inappwebview && window.flutter_inappwebview.callHandler){
          window.flutter_inappwebview.callHandler('Base',JSON.stringify({key: 'badge', value: {badge: badge}}));
        }
      }
    
      function webviewPrivacyPolicy(){
        if(window.flutter_inappwebview && window.flutter_inappwebview.callHandler){
          window.flutter_inappwebview.callHandler('Base',JSON.stringify({key: 'privacyPolicy'}));
        }
      }
    
      function webviewTermsOfUse(){
        if(window.flutter_inappwebview && window.flutter_inappwebview.callHandler){
          window.flutter_inappwebview.callHandler('Base',JSON.stringify({key: 'termsOfUse'}));
        }
      }
    
       function webviewBiometrics(){
        if(window.flutter_inappwebview && window.flutter_inappwebview.callHandler){
          window.flutter_inappwebview.callHandler('Base',JSON.stringify({key: 'biometrics'}));
        }
      }
    
      function receivePadding(top,bottom,left,right){
        const event = new CustomEvent('receivePadding', { detail: JSON.stringify({top, bottom, left,
        right}) });
        window.dispatchEvent(event);
      }
    
      function receiveToken(deviceToken, deviceInfo){
        console.log(deviceInfo.toString());
        const event = new CustomEvent('receiveToken', { detail: JSON.stringify({deviceToken, deviceInfo}) });
        window.dispatchEvent(event);
      }
    
      function receiveUserInfo(loginId, corp) {
        const event = new CustomEvent('receiveUserInfo', { detail: JSON.stringify({loginId, corp}) });
        window.dispatchEvent(event);
      }
    
      function receiveBack(){
        const event = new CustomEvent('receiveBack', { detail: {} });
        window.dispatchEvent(event);
      }
    
      function receiveBiometrics(didAuthenticate){
        const event = new CustomEvent('receiveBiometrics', { detail: JSON.stringify
        ({didAuthenticate}) });
        window.dispatchEvent(event);
      }
    
       function receiveKeyboard(isOpen, keyboardHeight){
        const event = new CustomEvent('receiveKeyboard', { detail: JSON.stringify({isOpen, keyboardHeight}) });
        window.dispatchEvent(event);
      }
    </script>
  </body>
</html>
